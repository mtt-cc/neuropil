/**
np_list.h contains header only list implementations for the c language.

The three supported list type a double linked, single linked and priority list.
All functions are defined as makros and should be used as templates,
concrete list functions will be generated by the pre-processor per defined type

copyright 2015 pi-lar GmbH

*/
#ifndef _NP_LIST_H_
#define _NP_LIST_H_

#ifdef __cplusplus
extern "C" {
#endif

/**
  .. c:macro:: np_pll_t(TYPE, NAME)

     defines a pointer to a priority list of type TYPE and variable NAME, variable is initialized with NULL

  .. c:function:: void pll_init(TYPE, priolist, cmp_func)
  .. c:function:: void pll_insert(TYPE, priolist, value, dups_ok)
  .. c:function:: void pll_remove(TYPE, priolist, value)
  .. c:function:: TYPE pll_head(TYPE, priolist)
  .. c:function:: void pll_free(TYPE, priolist)
  .. c:function:: void pll_clear(TYPE, priolist)
*/
#define np_pll_t(TYPE, NAME) TYPE##_pll_t* NAME;

#define pll_init(TYPE, priolist, cmp_func) priolist = TYPE##_pll_init(cmp_func);
#define pll_insert(TYPE, priolist, value, dups_ok) TYPE##_pll_insert(priolist, value, dups_ok);
#define pll_remove(TYPE, priolist, value) TYPE##_pll_remove(priolist, value);
#define pll_head(TYPE, priolist) TYPE##_pll_head(priolist);
#define pll_free(TYPE, priolist) TYPE##_pll_free(priolist);
#define pll_clear(TYPE, priolist) TYPE##_pll_clear(priolist);

// return type definition
#define pll_return(TYPE) TYPE##_pll_t*
#define pll_iterator(TYPE) TYPE##_pll_node_t*

// general purpose definitions
// #define pll_traverse(priolist, iter_item, elem)  for (iter_item = priolist->first, elem = iter_item->val; iter_item != NULL; iter_item = iter_item->flink, elem = iter_item->val)
// #define pll_rtraverse(priolist, iter_item, elem) for (iter_item = priolist->last,  elem = iter_item->val; iter_item != NULL; iter_item = iter_item->blink, elem = iter_item->val)
#define pll_empty(priolist)    (NULL == priolist->first)
#define pll_size(priolist)     (priolist->size)
#define pll_first(priolist)    (priolist->first)
#define pll_last(priolist)     (priolist->last)
#define pll_next(pll_elem)     (pll_elem = pll_elem->flink)
#define pll_get_next(pll_elem) (pll_elem->flink)
#define pll_has_next(pll_elem) (NULL != pll_elem->flink)
#define pll_previous(pll_elem) (pll_elem = pll_elem->blink)
#define pll_get_previous(pll_elem) (pll_elem->blink)
#define pll_has_previous(pll_elem) (NULL != pll_elem->blink)

/**
.. PLL (priority single linked list) prototype generator
*/
#define NP_PLL_GENERATE_PROTOTYPES(TYPE)\
	typedef int8_t (*TYPE##_cmp_func_t) (TYPE value_1, TYPE value_2 );\
	typedef struct TYPE##_pll_s TYPE##_pll_t;\
    typedef struct TYPE##_pll_node_s TYPE##_pll_node_t;\
    struct TYPE##_pll_s\
    {\
	    uint32_t size;\
	    TYPE##_pll_node_t *first;\
	    TYPE##_pll_node_t *last;\
	    TYPE##_cmp_func_t cmp_func;\
    };\
    struct TYPE##_pll_node_s\
    {\
	    TYPE##_pll_node_t *flink;\
	    TYPE##_pll_node_t *blink;\
        TYPE val;\
    };\
    TYPE##_pll_t* TYPE##_pll_init(TYPE##_cmp_func_t cmp_func);\
    void TYPE##_pll_insert(TYPE##_pll_t* pll_list, TYPE value, np_bool dups_ok);\
    void TYPE##_pll_remove(TYPE##_pll_t* pll_list, TYPE value);\
	TYPE TYPE##_pll_head(TYPE##_pll_t* list);\
    void TYPE##_pll_free(TYPE##_pll_t* list);\
    void TYPE##_pll_clear(TYPE##_pll_t* list);

/**
.. PLL (priority single linked list) implementation generator
*/
#define NP_PLL_GENERATE_IMPLEMENTATION(TYPE)\
TYPE##_pll_t* TYPE##_pll_init(TYPE##_cmp_func_t cmp_func) \
{ \
	TYPE##_pll_t* pll_list = (TYPE##_pll_t*) malloc(sizeof(TYPE##_pll_t)); \
	pll_list->size = 0; \
	pll_list->cmp_func = cmp_func; \
	pll_list->first = NULL; \
	pll_list->last = NULL; \
	return pll_list; \
} \
void TYPE##_pll_insert(TYPE##_pll_t* pll_list, TYPE value, np_bool dups_ok) \
{ \
	TYPE##_pll_node_t* new_pll_node = (TYPE##_pll_node_t*) malloc(sizeof(TYPE##_pll_node_t)); \
	new_pll_node->val = value; \
	new_pll_node->flink = NULL; \
	new_pll_node->blink = NULL; \
	if (pll_list->first == NULL) { \
		pll_list->first = new_pll_node; \
		pll_list->last = new_pll_node; \
		pll_list->size++; \
		return; \
	} \
	TYPE##_pll_node_t* pll_current = pll_list->first; \
	while (NULL != pll_current) { \
		int8_t cmp_res = pll_list->cmp_func(pll_current->val, new_pll_node->val); \
		if (cmp_res < 0) { \
			new_pll_node->flink = pll_current; \
			if (NULL != pll_current->blink) pll_current->blink->flink = new_pll_node; \
			new_pll_node->blink = pll_current->blink; \
			pll_current->blink = new_pll_node; \
			if (pll_current == pll_list->first) pll_list->first = new_pll_node; \
			break; \
		}\
		if ( (cmp_res == 0) && !dups_ok) return;\
		if (pll_current == pll_list->last) {\
			pll_current->flink = new_pll_node;\
			new_pll_node->blink = pll_current;\
			pll_list->last = new_pll_node;\
			break;\
		}\
		pll_current = pll_current->flink;\
	}\
	pll_list->size++;\
}\
void TYPE##_pll_remove(TYPE##_pll_t* pll_list, TYPE value) {\
	TYPE##_pll_node_t* pll_current = pll_list->first;\
	while (NULL != pll_current) {\
		int8_t cmp_res = pll_list->cmp_func(pll_current->val, value);\
		if (0 == cmp_res) {\
			if (NULL != pll_current->flink) pll_current->flink->blink = pll_current->blink;\
			if (NULL != pll_current->blink) pll_current->blink->flink = pll_current->flink;\
			if (pll_list->first == pll_current) pll_list->first = pll_current->flink;\
			if (pll_list->last == pll_current) pll_list->last = pll_current->blink;\
			free(pll_current);\
			pll_list->size--;\
			break;\
		} else {\
			pll_current = pll_current->flink;\
		}\
	}\
}\
TYPE TYPE##_pll_head(TYPE##_pll_t* pll_list) {\
	TYPE ret_val = 0;\
	if (NULL != pll_list->first) {\
		TYPE##_pll_node_t* tmp = pll_list->first;\
		ret_val = tmp->val;\
		pll_list->first = pll_list->first->flink;\
		if (pll_list->first != NULL) pll_list->first->blink = NULL;\
		if (pll_list->first == NULL) pll_list->last = NULL;\
		free(tmp);\
		pll_list->size--;\
	}\
	return ret_val;\
}\
void TYPE##_pll_free(TYPE##_pll_t* pll_list) {\
	TYPE##_pll_node_t *tmp;\
	while (NULL != pll_list->first) {\
		tmp = pll_list->first;\
		pll_list->first = pll_list->first->flink;\
		free(tmp);\
	}\
	free(pll_list);\
}\
void TYPE##_pll_clear(TYPE##_pll_t* pll_list) {\
	TYPE##_pll_node_t *tmp;\
	while (NULL != pll_list->first) {\
		tmp = pll_list->first;\
		pll_list->first = pll_list->first->flink;\
		free(tmp);\
	}\
}


/**
.. double linked list header only implementation for neuropil
*/
#define np_dll_t(TYPE, NAME) TYPE##_dll_t* NAME

// convenience wrapper definitions
#define dll_init(TYPE, dll_list) dll_list = TYPE##_dll_init();
#define dll_append(TYPE, dll_list, value) TYPE##_dll_append(dll_list, value);
#define dll_prepend(TYPE, dll_list, value) TYPE##_dll_prepend(dll_list, value);
#define	dll_head(TYPE, dll_list) TYPE##_dll_head(dll_list);
#define dll_tail(TYPE, dll_list) TYPE##_dll_tail(dll_list);
#define dll_free(TYPE, dll_list) TYPE##_dll_free(dll_list);
#define dll_clear(TYPE, dll_list) TYPE##_dll_free(dll_list);

// return type definition
#define dll_return(TYPE) TYPE##_dll_t*
#define dll_iterator(TYPE) TYPE##_dll_node_t*

// general purpose definitions
// #define dll_traverse(dll_list, iter_item, elem)  for (iter_item = dll_list->first, elem = iter_item->val; iter_item != NULL; iter_item = iter_item->flink, elem = iter_item->val)
// #define dll_rtraverse(dll_list, iter_item, elem) for (iter_item = dll_list->last,  elem = iter_item->val; iter_item != NULL; iter_item = iter_item->blink, elem = iter_item->val)
#define dll_empty(dll_list)    (NULL == dll_list->first)
#define dll_size(dll_list)     (dll_list->size)
#define dll_first(dll_list)    (dll_list->first)
#define dll_last(dll_list)     (dll_list->last)
#define dll_next(dll_elem)     (dll_elem = dll_elem->flink)
#define dll_get_next(sll_elem) (dll_elem->flink)
#define dll_previous(dll_elem) (dll_elem = dll_elem->blink)
#define dll_get_previous(sll_elem) (dll_elem->blink)

/**
  .. DLL (double linked list) prototype generator
 */
#define NP_DLL_GENERATE_PROTOTYPES(TYPE)\
	typedef struct TYPE##_dll_s TYPE##_dll_t;\
    typedef struct TYPE##_dll_node_s TYPE##_dll_node_t;\
    struct TYPE##_dll_s\
    {\
	    uint32_t size;\
	    TYPE##_dll_node_t *first;\
	    TYPE##_dll_node_t *last;\
    };\
    struct TYPE##_dll_node_s\
    {\
	    TYPE##_dll_node_t *flink;\
	    TYPE##_dll_node_t *blink;\
        TYPE* val;\
    };\
    TYPE##_dll_t* TYPE##_dll_init();\
    void TYPE##_dll_append(TYPE##_dll_t* dll_list, TYPE* value);\
    void TYPE##_dll_prepend(TYPE##_dll_t* dll_list, TYPE* value);\
	TYPE* TYPE##_dll_head(TYPE##_dll_t* list);\
    TYPE* TYPE##_dll_tail(TYPE##_dll_t* list);\
    void TYPE##_dll_free(TYPE##_dll_t* list);\
    void TYPE##_dll_clear(TYPE##_dll_t* list);

/**
.. DLL (double linked list) implementation generator
 **/
#define NP_DLL_GENERATE_IMPLEMENTATION(TYPE)\
TYPE##_dll_t* TYPE##_dll_init() {\
	TYPE##_dll_t* dll_list = (TYPE##_dll_t*) malloc(sizeof(TYPE##_dll_t));\
	dll_list->size = 0;\
	dll_list->first = NULL;\
	dll_list->last = NULL;\
	return dll_list;\
}\
void TYPE##_dll_append(TYPE##_dll_t* dll_list, TYPE* value) {\
	TYPE##_dll_node_t* dll_node = (TYPE##_dll_node_t*) malloc(sizeof(TYPE##_dll_node_t));\
	dll_node->val = value;\
	dll_node->flink = NULL;\
	dll_node->blink = NULL;\
	if (NULL != dll_list->last) {\
		dll_node->blink = dll_list->last;\
		dll_list->last->flink = dll_node;\
		dll_list->last = dll_node;\
	} else {\
		dll_list->first = dll_node; dll_list->last = dll_node;\
	}\
	dll_list->size++;\
}\
void TYPE##_dll_prepend(TYPE##_dll_t* dll_list, TYPE* value) {\
	TYPE##_dll_node_t* dll_node = (TYPE##_dll_node_t*) malloc(sizeof(TYPE##_dll_node_t));\
	dll_node->val = value;\
	dll_node->flink = NULL;\
	dll_node->blink = NULL;\
	if (NULL != dll_list->first) {\
		dll_node->flink = dll_list->first;\
		dll_list->first->blink = dll_node;\
		dll_list->first = dll_node;\
	} else {\
		dll_list->first = dll_node; dll_list->last = dll_node;\
	}\
	dll_list->size++;\
}\
TYPE* TYPE##_dll_head(TYPE##_dll_t* dll_list) {\
	TYPE* ret_val = NULL;\
	if (NULL != dll_list->first) {\
		TYPE##_dll_node_t* tmp = dll_list->first;\
		ret_val = tmp->val;\
		dll_list->first = dll_list->first->flink;\
		if (dll_list->first != NULL) dll_list->first->blink = NULL;\
		if (dll_list->first == NULL) dll_list->last = NULL;\
		free(tmp);\
		dll_list->size--;\
	}\
	return ret_val;\
}\
TYPE* TYPE##_dll_tail(TYPE##_dll_t* dll_list) {\
	TYPE* ret_val = NULL;\
	if (NULL != dll_list->last) {\
		TYPE##_dll_node_t* tmp = dll_list->last;\
		ret_val = tmp->val;\
		dll_list->last = dll_list->last->blink;\
		if (dll_list->last != NULL) dll_list->last->flink = NULL;\
		if (dll_list->last == NULL) dll_list->first = NULL;\
		free(tmp);\
		dll_list->size--;\
	}\
	return ret_val;\
}\
void TYPE##_dll_free(TYPE##_dll_t* dll_list) {\
	TYPE##_dll_node_t *tmp;\
	while (dll_list->first != NULL) {\
		tmp = dll_list->first;\
		dll_list->first = dll_list->first->flink;\
		free(tmp);\
	}\
	free(dll_list);\
}\
void TYPE##_dll_clear(TYPE##_dll_t* dll_list) {\
	TYPE##_dll_node_t *tmp;\
	while (dll_list->first != NULL) {\
		tmp = dll_list->first;\
		dll_list->first = dll_list->first->flink;\
		free(tmp);\
	}\
}

/**
.. single linked list header only implementation for neuropil
 **/
// definition
#define np_sll_t(TYPE, NAME) TYPE##_sll_t* NAME

// convenience wrapper definitions
#define sll_init(TYPE, sll_list) sll_list = TYPE##_sll_init();
#define sll_append(TYPE, sll_list, value) TYPE##_sll_append(sll_list, value);
#define sll_prepend(TYPE, sll_list, value) TYPE##_sll_prepend(sll_list, value);
#define	sll_head(TYPE, sll_list) TYPE##_sll_head(sll_list)
#define sll_tail(TYPE, sll_list) TYPE##_sll_tail(sll_list)
#define sll_free(TYPE, sll_list) TYPE##_sll_free(sll_list)
#define sll_clear(TYPE, sll_list) TYPE##_sll_clear(sll_list)
#define sll_delete(TYPE, sll_list, iter) TYPE##_sll_delete(sll_list, iter)

// return type definition
#define sll_return(TYPE) TYPE##_sll_t*
#define sll_iterator(TYPE) TYPE##_sll_node_t*

// general purpose definitions
// #define sll_traverse(sll_list, iter_item, elem) for (iter_item = sll_list->first, elem = iter_item->val; iter_item != NULL; iter_item = iter_item->flink, elem = iter_item->val)
// #define sll_rtraverse(sll_list, iter_item, elem) for (iter_item = sll_list->last,  elem = iter_item->val; iter_item != NULL; iter_item = iter_item->blink, elem = iter_item->val)
#define sll_empty(sll_list) (NULL == sll_list->first)
#define sll_size(sll_list) sll_list->size
#define sll_first(sll_list) (sll_list->first)
#define sll_last(sll_list) (sll_list->last)
#define sll_next(sll_elem) (sll_elem = sll_elem->flink)
#define sll_get_next(sll_elem) (sll_elem->flink)
// #define sll_previous(sll_elem) (sll_elem->blink)

/**
.. SLL (single linked list) prototype generator
 **/
#define NP_SLL_GENERATE_PROTOTYPES(TYPE)\
	typedef struct TYPE##_sll_s TYPE##_sll_t;\
	typedef struct TYPE##_sll_node_s TYPE##_sll_node_t;\
	struct TYPE##_sll_s\
	{\
		uint32_t size;\
		TYPE##_sll_node_t *first;\
		TYPE##_sll_node_t *last;\
	};\
	struct TYPE##_sll_node_s\
	{\
		TYPE##_sll_node_t *flink;\
    	TYPE* val;\
	};\
	TYPE##_sll_t* TYPE##_sll_init();\
    void TYPE##_sll_append(TYPE##_sll_t* sll_list, TYPE* value);\
    void TYPE##_sll_prepend(TYPE##_sll_t* sll_list, TYPE* value);\
	TYPE* TYPE##_sll_head(TYPE##_sll_t* list);\
    TYPE* TYPE##_sll_tail(TYPE##_sll_t* list);\
    void TYPE##_sll_free(TYPE##_sll_t* list);\
    void TYPE##_sll_clear(TYPE##_sll_t* list);\
    void TYPE##_sll_delete(TYPE##_sll_t* list, TYPE##_sll_node_t* tbr);

/**
.. SLL (single linked list) implementation generator
 **/
#define NP_SLL_GENERATE_IMPLEMENTATION(TYPE)\
TYPE##_sll_t* TYPE##_sll_init() {\
	TYPE##_sll_t* sll_list = (TYPE##_sll_t*) malloc(sizeof(TYPE##_sll_t));\
	sll_list->size = 0;\
	sll_list->first = NULL;\
	sll_list->last = NULL;\
	return sll_list;\
}\
void TYPE##_sll_append(TYPE##_sll_t* sll_list, TYPE* value) {\
	TYPE##_sll_node_t* sll_node = (TYPE##_sll_node_t*) malloc(sizeof(TYPE##_sll_node_t));\
	sll_node->val = value;\
	sll_node->flink = NULL;\
	if (sll_list->first == NULL) { sll_list->first = sll_node; sll_list->last = sll_node; }\
	if (sll_list->last != sll_node) {\
		sll_list->last->flink = sll_node;\
		sll_list->last = sll_node;\
	}\
	sll_list->size++;\
}\
void TYPE##_sll_prepend(TYPE##_sll_t* sll_list, TYPE* value) {\
	TYPE##_sll_node_t* sll_node = (TYPE##_sll_node_t*) malloc(sizeof(TYPE##_sll_node_t));\
	sll_node->val = value;\
	sll_node->flink = NULL;\
	if (sll_list->first == NULL) { sll_list->first = sll_node; sll_list->last = sll_node; }\
	if (sll_list->first != sll_node) {\
		sll_node->flink = sll_list->first;\
		sll_list->first = sll_node;\
	}\
	sll_list->size++;\
}\
TYPE* TYPE##_sll_head(TYPE##_sll_t* sll_list) {\
	TYPE* ret_val = NULL;\
	if (NULL != sll_list->first) {\
		TYPE##_sll_node_t* tmp = sll_list->first;\
		ret_val = tmp->val;\
		sll_list->first = sll_list->first->flink;\
		if (sll_list->first == NULL) sll_list->last = NULL; \
		free(tmp);\
		sll_list->size--;\
	}\
	return ret_val;\
}\
TYPE* TYPE##_sll_tail(TYPE##_sll_t* sll_list) {\
	TYPE* ret_val = NULL;\
	if (NULL != sll_list->last) {\
		TYPE##_sll_node_t* tmp = sll_list->last;\
		ret_val = tmp->val;\
		TYPE##_sll_node_t* tmp_list_elem = sll_list->first;\
		if(sll_list->first != sll_list->last) {\
		    while (tmp_list_elem->flink != sll_list->last) { tmp_list_elem = tmp_list_elem->flink; }\
		    sll_list->last = tmp_list_elem;\
		    sll_list->last->flink = NULL;\
		} else {\
			sll_list->last = NULL; sll_list->first = NULL; \
		}\
		free(tmp);\
		sll_list->size--;\
	}\
	return ret_val;\
}\
void TYPE##_sll_free(TYPE##_sll_t* sll_list) {\
	TYPE##_sll_node_t *tmp;\
	while (NULL != sll_list->first) {\
		tmp = sll_list->first;\
		sll_list->first = sll_list->first->flink;\
		free(tmp);\
	}\
	free(sll_list);\
}\
void TYPE##_sll_clear(TYPE##_sll_t* sll_list) {\
	TYPE##_sll_node_t *tmp;\
	while (sll_list->first != NULL) {\
		tmp = sll_list->first;\
		sll_list->first = sll_list->first->flink;\
		free(tmp);\
		sll_list->size--;\
	}\
}\
void TYPE##_sll_delete(TYPE##_sll_t* sll_list, TYPE##_sll_node_t *tbr) {\
	if (sll_list->first == tbr) {\
		sll_list->first = tbr->flink;\
		free(tbr);\
		sll_list->size--;\
	} else {\
		TYPE##_sll_node_t *tmp = sll_list->first;\
		TYPE##_sll_node_t *mem = sll_list->first;\
		while (tmp->flink != NULL) {\
			tmp = tmp->flink;\
			if (tmp == tbr) {\
				mem->flink = tbr->flink;\
				free(tmp);\
				sll_list->size--;\
				break;\
			} else {\
				mem = mem->flink;\
			}\
		}\
	}\
}

#ifdef __cplusplus
}
#endif

#endif // _NP_LIST_H_
